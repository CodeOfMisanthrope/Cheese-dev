{"version":3,"file":"bundle.min.js","sources":["../node_modules/tslib/tslib.es6.js","../src/lib/core/cache-data/strategy/simple/index.ts","../src/lib/core/err/option/index.ts","../src/lib/core/err/result/index.ts","../src/lib/core/linked-list/singly/node.ts","../src/lib/core/linked-list/singly/list.ts","../src/lib/core/linked-list/first-last/node.ts","../src/lib/core/linked-list/first-last/list.ts","../src/lib/core/linked-list/double/node.ts","../src/lib/core/linked-list/double/list.ts","../src/lib/core/logger/engines/console.ts","../src/lib/core/queue/simple/index.ts","../src/lib/core/queue/deque/index.ts","../src/lib/core/range/index.ts","../src/lib/core/stack/index.ts","../src/lib/core/text/lines.ts","../src/lib/core/text/words.ts","../src/lib/core/cache-data/cache-data.ts","../src/lib/core/event/index.ts","../src/lib/core/cache-data/strategy/lru/index.ts","../src/lib/core/logger/index.ts","../src/lib/core/iter/async.ts","../src/lib/core/fn-tools/index.ts","../src/lib/core/iter/index.ts","../src/lib/core/event/stream.ts","../src/lib/core/symbol/index.ts","../src/lib/core/object/watch/index.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import type { CacheStrategy } from \"~core/cache-data/strategy/interface\";\n\n/**\n * @description Класс простого кеширования.\n */\nexport default class SimpleCache<T> implements CacheStrategy<T> {\n\t#cacheMap: Map<string, T>;\n\n\tconstructor() {\n\t\tthis.#cacheMap = new Map([]);\n\t}\n\n\tpublic hasKey(key: string): boolean {\n\t\treturn this.#cacheMap.has(key);\n\t}\n\n\tpublic get(key: string): T | undefined {\n\t\treturn this.#cacheMap.get(key);\n\t}\n\n\tpublic set(key: string, value: T): void {\n\t\tthis.#cacheMap.set(key, value);\n\t}\n\n\tpublic remove(key: string): void {\n\t\tthis.#cacheMap.delete(key);\n\t}\n\n\tpublic clear(): void {\n\t\tthis.#cacheMap.clear();\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this.#cacheMap.size === 0;\n\t}\n\n\tpublic isFull(): boolean {\n\t\treturn false;\n\t}\n}\n","/**\n * @description Класс Option представляет обертку над данными, которых может не быть.\n */\nexport default class Option<T> {\n\tstatic None = undefined;\n\n\t/**\n\t * @description возвращает true, если данных нет, и false в обратном случае.\n\t */\n\tget isNone(): boolean {\n\t\treturn this.#data == null;\n\t}\n\n\treadonly #data: Nullable<T>;\n\n\tconstructor(data: Nullable<T>) {\n\t\tthis.#data = data;\n\t}\n\n\t/**\n\t * @description Возвращает данные, либо кидает исключение (данных нет).\n\t */\n\tpublic unwrap() {\n\t\tif (this.#data == null) {\n\t\t\tthrow new Error(\"Data in none\");\n\t\t}\n\n\t\treturn this.#data;\n\t}\n\n\t/**\n\t * @description Возвращает новый объект Option. Принимает callback, и в новый option будет возвращаться то, что\n\t * функция вернула. Но если данные isNone, то возвращается Option(Option.None)\n\t * @param cb\n\t */\n\tpublic then(cb: (data: T) => Nullable<T>) {\n\t\tif (this.#data == null) {\n\t\t\treturn new Option<T>(Option.None);\n\t\t}\n\n\t\ttry {\n\t\t\treturn new Option<T>(cb(this.#data));\n\t\t} catch (err) {\n\t\t\treturn new Option<T>(Option.None);\n\t\t}\n\t}\n\n\t/**\n\t * @description Принимает новый объект Option и возвращает его, если данные None\n\t * @param option\n\t */\n\tpublic or(option: Option<T>) {\n\t\tif (this.isNone) {\n\t\t\t// todo\n\t\t\t// if (option instanceof Option) {\n\t\t\treturn option;\n\t\t\t// }\n\n\t\t\t// return new Option(option);\n\t\t}\n\n\t\treturn this;\n\t}\n}\n","/**\n * @description Класс Result представляет обёртку над данными, которых могут содержать ошибку.\n */\nexport default class Result<T> {\n\treadonly #data: CanError<T>;\n\n\t/**\n\t * @description возвращает true, если данные содержат ошибку, и false в обратном случае.\n\t */\n\tget isError() {\n\t\treturn this.#data instanceof Error;\n\t}\n\n\tconstructor(data: CanError<T>) {\n\t\tthis.#data = data;\n\t}\n\n\t/**\n\t * @description возвращает данные, или кидает исключение (если есть ошибка).\n\t */\n\tpublic unwrap() {\n\t\tif (this.isError) {\n\t\t\tthrow this.#data;\n\t\t}\n\n\t\treturn this.#data;\n\t}\n\n\t/**\n\t * @description Возвращает новый объект Result. Принимает callback, и в новый Result будет возвращаться то, что\n\t * функция вернула. Но если данные isError, то возвращается Result(this.#data)\n\t * @param cb\n\t */\n\tpublic then(cb: (data: CanError<T>) => unknown) {\n\t\tconsole.log(this.#data);\n\t\tif (this.isError) {\n\t\t\treturn new Result(this.#data);\n\t\t}\n\n\t\ttry {\n\t\t\treturn new Result(cb(this.#data));\n\t\t} catch (err) {\n\t\t\treturn new Result(err);\n\t\t}\n\t}\n\n\t/**\n\t * @description Возвращает новый объект Result. Принимает callback, и в новый Result будет возвращаться то, что\n\t * функция вернула, если есть ошибка. Но если данные не isError, то возвращается Result(this.#data).\n\t * @param cb\n\t */\n\tpublic catch(cb: (data: CanError<T>) => unknown) {\n\t\tif (!this.isError) {\n\t\t\treturn new Result(this.#data);\n\t\t}\n\n\t\ttry {\n\t\t\treturn new Result(cb(this.#data));\n\t\t} catch (err) {\n\t\t\treturn new Result(err);\n\t\t}\n\t}\n}\n","/**\n * @description Узел односвязного списка.\n * @template T - Тип значения (тела) узла.\n */\nexport default class LLNode<T> {\n\t/**\n\t * @description Ссылка на следующий узел.\n\t */\n\tpublic next: LLNode<T> | null;\n\n\t/**\n\t * @description Значение (тело) узла.\n\t */\n\tpublic data: T;\n\n\tconstructor(data: T, next?: LLNode<T> | null) {\n\t\tthis.data = data;\n\t\tthis.next = next ?? null;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\tlet node: CanNull<LLNode<T>> = this;\n\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tif (node) {\n\t\t\t\t\tconst temp = node;\n\t\t\t\t\tnode = node.next;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: temp.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: null,\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t};\n\t}\n}\n","import LLNode from \"~core/linked-list/singly/node\";\n\n/**\n * @description Класс односвязного списка.\n * @template T - Тип значения узла списка.\n */\nexport default class LinkedList<T> {\n\t/**\n\t * @description Возвращает первый узел списка.\n\t */\n\tget first(): CanNull<T> {\n\t\treturn this.firstNode?.data ?? null;\n\t}\n\n\t/**\n\t * @description Возвращает длину списка.\n\t */\n\tget length(): number {\n\t\treturn this.lengthList;\n\t}\n\n\t/**\n\t * @description Ссылка на первый элемент списка.\n\t * @protected\n\t */\n\tprotected firstNode: CanNull<LLNode<T>> = null;\n\n\t/**\n\t * @description Длина списка.\n\t * @protected\n\t */\n\tprotected lengthList: number = 0;\n\n\tconstructor(iterable?: Iterable<T>) {\n\t\tif (iterable) {\n\t\t\tfor (const el of iterable) {\n\t\t\t\tthis.insertFirst(el);\n\t\t\t}\n\t\t}\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\tif (this.firstNode) {\n\t\t\treturn this.firstNode[Symbol.iterator]();\n\t\t}\n\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: null,\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * @description Добавляет элемент в начало списка.\n\t * @param {T} item Новый элемент списка.\n\t */\n\tpublic insertFirst(item: T): void {\n\t\tconst newNode: LLNode<T> = new LLNode(item);\n\t\tthis.lengthList++;\n\t\tnewNode.next = this.firstNode;\n\t\tthis.firstNode = newNode;\n\t}\n\n\t/**\n\t * @description Удаляет элемент из начала списка.\n\t * @return {T | null}\n\t */\n\tpublic removeFirst(): T | null {\n\t\tif (this.firstNode === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst val: LLNode<T> = this.firstNode;\n\t\tthis.lengthList--;\n\t\tthis.firstNode = this.firstNode.next;\n\t\treturn val.data;\n\t}\n\n\t/**\n\t * @description Разворачивает список.\n\t */\n\tpublic reverse() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet prev: CanNull<LLNode<T>> = null,\n\t\t\tcurrent: CanNull<LLNode<T>> = this.firstNode,\n\t\t\tnext: CanNull<LLNode<T>> = null;\n\n\t\twhile (current !== null) {\n\t\t\tnext = current.next;\n\t\t\tcurrent.next = prev;\n\t\t\tprev = current;\n\t\t\tcurrent = next;\n\t\t}\n\n\t\tthis.firstNode = prev;\n\t}\n\n\t/**\n\t * @description Возвращает true, если список пустой,\n\t * и false в обратном случае.\n\t * @return boolean\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn this.firstNode === null;\n\t}\n\n\t/**\n\t * @description Очищает список.\n\t */\n\tpublic clear(): void {\n\t\tthis.lengthList = 0;\n\t\tthis.firstNode = null;\n\t}\n}\n","/**\n * @description Узел двустороннего списка.\n * @template T - Тип значения (тела) узла.\n */\nexport default class FLNode<T> {\n\t/**\n\t * @description Ссылка на следующий узел.\n\t */\n\tpublic next: FLNode<T> | null;\n\n\t/**\n\t * @description Значение (тело) узла.\n\t */\n\tpublic data: T;\n\n\tconstructor(data: T, next?: FLNode<T> | null) {\n\t\tthis.data = data;\n\t\tthis.next = next ?? null;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\tlet node: CanNull<FLNode<T>> = this;\n\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tif (node) {\n\t\t\t\t\tconst temp = node;\n\t\t\t\t\tnode = node.next;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: temp.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: null,\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t};\n\t}\n}\n","import FLNode from \"~core/linked-list/first-last/node\";\n\n/**\n * @description Класс двустороннего списка.\n * @template T - Тип значения узла списка.\n */\nexport default class FirstLastList<T> {\n\t/**\n\t * @description Возвращает первый узел списка.\n\t */\n\tget first(): CanNull<T> {\n\t\treturn this.firstNode?.data ?? null;\n\t}\n\n\t/**\n\t * @description Возвращает первый узел списка.\n\t */\n\tget last(): CanNull<T> {\n\t\treturn this.lastNode?.data ?? null;\n\t}\n\n\t/**\n\t * @description Возвращает длину списка.\n\t */\n\tget length(): number {\n\t\treturn this.lengthList;\n\t}\n\n\t/**\n\t * @description Ссылка на первый элемент списка.\n\t * @protected\n\t */\n\tprotected firstNode: CanNull<FLNode<T>> = null;\n\n\t/**\n\t * @description Ссылка на последний элемент списка.\n\t * @protected\n\t */\n\tprotected lastNode: CanNull<FLNode<T>> = null;\n\n\t/**\n\t * @description Длина списка.\n\t * @protected\n\t */\n\tprotected lengthList: number = 0;\n\n\tconstructor(iterable?: Iterable<T>) {\n\t\tif (iterable) {\n\t\t\tfor (const el of iterable) {\n\t\t\t\tthis.insertFirst(el);\n\t\t\t}\n\t\t}\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\tif (this.firstNode) {\n\t\t\treturn this.firstNode[Symbol.iterator]();\n\t\t}\n\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: null,\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * @description Добавляет элемент в начало списка.\n\t * @param {T} item - Новый элемент списка.\n\t */\n\tpublic insertFirst(item: T): void {\n\t\tconst newNode: FLNode<T> = new FLNode(item);\n\n\t\tthis.lengthList++;\n\n\t\tif (this.firstNode === null) {\n\t\t\tthis.lastNode = newNode;\n\t\t}\n\n\t\tnewNode.next = this.firstNode;\n\t\tthis.firstNode = newNode;\n\t}\n\n\t/**\n\t * @description Удаляет элемент из начала списка.\n\t * @return {T | null}\n\t */\n\tpublic removeFirst(): T | null {\n\t\tif (this.firstNode === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.firstNode.next === null) {\n\t\t\tthis.lastNode = null;\n\t\t}\n\n\t\tconst val: FLNode<T> = this.firstNode;\n\t\tthis.lengthList--;\n\t\tthis.firstNode = this.firstNode.next;\n\t\treturn val.data;\n\t}\n\n\t/**\n\t * @description Добавляет элемент в конец списка.\n\t * @param {T} item - Новый элемент списка.\n\t */\n\tpublic insertLast(item: T): void {\n\t\tconst newNode: FLNode<T> = new FLNode(item);\n\n\t\tthis.lengthList++;\n\n\t\tif (this.lastNode === null) {\n\t\t\tthis.firstNode = newNode;\n\t\t\tthis.lastNode = newNode;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.lastNode.next = newNode;\n\t\tthis.lastNode = newNode;\n\t}\n\n\t/**\n\t * @description Разворачивает список.\n\t */\n\tpublic reverse() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet prev: CanNull<FLNode<T>> = null,\n\t\t\tnext: CanNull<FLNode<T>> = null,\n\t\t\tcurrent: CanNull<FLNode<T>> = this.firstNode;\n\n\t\twhile (current !== null) {\n\t\t\tnext = current.next;\n\t\t\tcurrent.next = prev;\n\t\t\tprev = current;\n\t\t\tcurrent = next;\n\t\t}\n\n\t\t[this.lastNode, this.firstNode] = [this.firstNode, prev];\n\t}\n\n\t/**\n\t * @description Возвращает true, если список пустой, и false\n\t * в обратном случае.\n\t * @return boolean\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn this.firstNode === null && this.lastNode === null;\n\t}\n\n\t/**\n\t * @description Очищает список.\n\t */\n\tpublic clear(): void {\n\t\tthis.firstNode = null;\n\t\tthis.lastNode = null;\n\t\tthis.lengthList = 0;\n\t}\n}\n","/**\n * @description Узел двустороннего списка.\n */\nexport default class DLNode<T> {\n\t/**\n\t * @description Ссылка на предыдущий узел.\n\t */\n\tpublic prev: DLNode<T> | null;\n\n\t/**\n\t * @description Ссылка на следующий узел.\n\t */\n\tpublic next: DLNode<T> | null;\n\n\t/**\n\t * @description Значение (тело) узла.\n\t */\n\tpublic data: T;\n\n\tconstructor(data: T, prev?: CanNull<DLNode<T>>, next?: CanNull<DLNode<T>>) {\n\t\tthis.data = data;\n\t\tthis.prev = prev ?? null;\n\t\tthis.next = next ?? null;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\tlet node: CanNull<DLNode<T>> = this;\n\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tif (node) {\n\t\t\t\t\tconst temp = node;\n\t\t\t\t\tnode = node.next;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: temp.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: null,\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t};\n\t}\n}\n","import DLNode from \"~core/linked-list/double/node\";\n\n/**\n * @description Класс двустороннего списка.\n * @template T\n */\nexport default class DoubleLinkedList<T> {\n\t/**\n\t * @description Возвращает первый узел списка.\n\t */\n\tget first(): CanNull<T> {\n\t\treturn this.firstNode?.data ?? null;\n\t}\n\n\t/**\n\t * @description Возвращает первый узел списка.\n\t */\n\tget last(): CanNull<T> {\n\t\treturn this.lastNode?.data ?? null;\n\t}\n\n\t/**\n\t * @description Возвращает длину списка.\n\t */\n\tget length(): number {\n\t\treturn this.lengthList;\n\t}\n\n\t/**\n\t * @description Ссылка на первый элемент списка.\n\t * @protected\n\t */\n\tprotected firstNode: CanNull<DLNode<T>> = null;\n\n\t/**\n\t * @description Ссылка на последний элемент списка.\n\t * @protected\n\t */\n\tprotected lastNode: CanNull<DLNode<T>> = null;\n\n\t/**\n\t * @description Длина списка.\n\t * @protected\n\t */\n\tprotected lengthList: number = 0;\n\n\tconstructor(iterable?: Iterable<T>) {\n\t\tif (iterable) {\n\t\t\tfor (const el of iterable) {\n\t\t\t\tthis.insertFirst(el);\n\t\t\t}\n\t\t}\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\tif (this.firstNode) {\n\t\t\treturn this.firstNode[Symbol.iterator]();\n\t\t}\n\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: null,\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * @description Добавляет элемент в начало списка.\n\t * @param {T} item - Новый элемент списка.\n\t */\n\tpublic insertFirst(item: T): void {\n\t\tconst newNode: DLNode<T> = new DLNode(item);\n\n\t\tif (this.firstNode == null) {\n\t\t\tthis.lastNode = newNode;\n\t\t} else {\n\t\t\tthis.firstNode.prev = newNode;\n\t\t}\n\n\t\tnewNode.next = this.firstNode;\n\t\tthis.firstNode = newNode;\n\t}\n\n\t/**\n\t * @description Удаляет элемент из начала списка.\n\t * @return {T | null}\n\t */\n\tpublic removeFirst(): T | null {\n\t\tif (this.firstNode == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst val = this.firstNode;\n\n\t\tif (this.firstNode.next === null) {\n\t\t\tthis.lastNode = null;\n\t\t} else {\n\t\t\tthis.firstNode.next.prev = null;\n\t\t}\n\n\t\tthis.firstNode = this.firstNode.next;\n\t\treturn val.data;\n\t}\n\n\t/**\n\t * @description Добавляет элемент в конец списка.\n\t * @param {T} item - Новый элемент списка.\n\t */\n\tpublic insertLast(item: T) {\n\t\tconst newNode: DLNode<T> = new DLNode(item);\n\n\t\tif (this.lastNode === null) {\n\t\t\tthis.firstNode = newNode;\n\t\t} else {\n\t\t\tthis.lastNode.next = newNode;\n\t\t\tnewNode.prev = this.lastNode;\n\t\t}\n\n\t\tthis.lastNode = newNode;\n\t}\n\n\t/**\n\t * @description Удаляет элемент из конца списка.\n\t * @return {T | null}\n\t */\n\tpublic removeLast(): T | null {\n\t\tif (this.firstNode == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.lastNode == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst val = this.lastNode;\n\n\t\tif (this.lastNode.prev === null) {\n\t\t\tthis.firstNode = null;\n\t\t} else {\n\t\t\tthis.lastNode.prev.next = null;\n\t\t}\n\n\t\tthis.lastNode = this.lastNode.prev;\n\t\treturn val.data;\n\t}\n\n\t/**\n\t * @description Возвращает true, если список пустой, и false в обратном случае.\n\t * @return boolean\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn this.firstNode == null && this.lastNode == null;\n\t}\n\n\t/**\n\t * @description Очищает список.\n\t */\n\tpublic clear(): void {\n\t\tthis.firstNode = null;\n\t\tthis.lastNode = null;\n\t}\n}\n","import { LoggerEngine } from \"~core/logger/engines/interface\";\n\nexport default class ConsoleEngine implements LoggerEngine {\n\t#getStyleConfig() {\n\t\t// todo\n\t}\n\n\tconstructor() {}\n\n\tpublic log(msg: string, ...args: unknown[]) {\n\t\tconsole.log(msg, ...args);\n\t}\n\n\tpublic warn(msg: string, ...args: unknown[]) {\n\t\tconsole.warn(msg, ...args);\n\t}\n\n\tpublic error(err: string | Error, ...args: unknown[]) {\n\t\tconsole.error(err, ...args);\n\t}\n}\n","import { FirstLastList } from \"~core/linked-list\";\n\n/**\n * @description Класс очереди.\n * @template T - Тип значения элемента очереди.\n */\nexport default class Queue<T> {\n\t/**\n\t * @description Возвращает первый элемент очереди.\n\t */\n\tget first() {\n\t\treturn this.innerStruct.first;\n\t}\n\n\t/**\n\t * @description Возвращает первый элемент очереди.\n\t */\n\tget last() {\n\t\treturn this.innerStruct.last;\n\t}\n\n\t/**\n\t * @description Возвращает длину очереди.\n\t */\n\tget length() {\n\t\treturn this.innerStruct.length;\n\t}\n\n\t/**\n\t * @description Внутреняя структура для очереди.\n\t * @protected\n\t */\n\tprotected innerStruct: FirstLastList<T>;\n\n\tconstructor(iterable?: Iterable<T>) {\n\t\tthis.innerStruct = new FirstLastList<T>(iterable);\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\treturn this.innerStruct[Symbol.iterator]();\n\t}\n\n\t/**\n\t * @description Добавляет элемент в очередь.\n\t * @param {T} item Новый элемент очереди.\n\t */\n\tpublic insert(item: T) {\n\t\tthis.innerStruct.insertLast(item);\n\t}\n\n\t/**\n\t * @description Извлекает элемент из очереди.\n\t */\n\tpublic remove() {\n\t\treturn this.innerStruct.removeFirst();\n\t}\n\n\t/**\n\t * @description Возвращает true, если очередь пуста, и false в обратном случае.\n\t * @return boolean\n\t */\n\tpublic isEmpty() {\n\t\treturn this.innerStruct.isEmpty();\n\t}\n\n\t/**\n\t * @description Очищает очередь.\n\t */\n\tpublic clear() {\n\t\tthis.innerStruct.clear();\n\t}\n}\n","import DoubleLinkedList from \"~core/linked-list/double\";\n\n/**\n * @description Класс двусторней очереди.\n * @template T - Тип значения элемента очереди.\n */\nexport default class Deque<T> {\n\t/**\n\t * @description Возвращает первый элемент очереди.\n\t */\n\tget first() {\n\t\treturn this.innerStruct.first;\n\t}\n\n\t/**\n\t * @description Возвращает первый элемент очереди.\n\t */\n\tget last() {\n\t\treturn this.innerStruct.last;\n\t}\n\n\t/**\n\t * @description Возвращает длину очереди.\n\t */\n\tget length() {\n\t\treturn this.innerStruct.length;\n\t}\n\n\t/**\n\t * @description Внутреняя структура для очереди.\n\t * @protected\n\t */\n\tprotected innerStruct: DoubleLinkedList<T>;\n\n\tconstructor(iterable?: Iterable<T>) {\n\t\tthis.innerStruct = new DoubleLinkedList<T>(iterable);\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\treturn this.innerStruct[Symbol.iterator]();\n\t}\n\n\t/**\n\t * @description Добавляет элемент в начало очереди.\n\t * @param {T} item Новый элемент очереди.\n\t */\n\tpublic insertFirst(item: T) {\n\t\tthis.innerStruct.insertFirst(item);\n\t}\n\n\t/**\n\t * @description Извлекает элемент из начала очереди.\n\t */\n\tpublic removeFirst() {\n\t\treturn this.innerStruct.removeFirst();\n\t}\n\n\t/**\n\t * @description Добавляет элемент в конец очереди.\n\t * @param {T} item Новый элемент очереди.\n\t */\n\tpublic insertLast(item: T) {\n\t\tthis.innerStruct.insertLast(item);\n\t}\n\n\t/**\n\t * @description Извлекает элемент из конца очереди.\n\t */\n\tpublic removeLast() {\n\t\treturn this.innerStruct.removeLast();\n\t}\n\n\t/**\n\t * @description Возвращает true, если очередь пуста, и false в обратном случае.\n\t * @return {boolean}\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn this.innerStruct.isEmpty();\n\t}\n\n\t/**\n\t * @description Очищает очередь.\n\t */\n\tpublic clear() {\n\t\tthis.innerStruct.clear();\n\t}\n}\n","import { RangeType, RangeVal } from \"~core/range/interfaces\";\n\n/**\n * A class representing a range of values (either numbers or characters).\n *\n * @remarks\n * This class allows you to create ranges of values that can be either numeric\n * or string-based. When creating an instance of the class, it checks that the\n * start and end values are of the same type. If they are different, a\n * `TypeError` is thrown with the message \"Start and end must be of the same type.\"\n *\n * @example\n * Example usage:\n * ```typescript\n * const r = new Range(\"a\", \"c\");\n * console.log([...r]); // ['a', 'b', 'c']\n *\n * const r2 = new Range(1, 3);\n * console.log([...r2]); // [1, 2, 3]\n *\n * for (const n of new Range(1,3)) {\n * \tconsole.log(n); // Outputs: 1, 2, 3\n * }\n *\n * const r4 = new Range(1, \"c\"); // Uncaught TypeError: Start and end must be of the same type.\n * ```\n */\nexport class Range {\n\t/**\n\t * The starting value of the range.\n\t */\n\tprotected start: number;\n\n\t/**\n\t * The ending value of the range.\n\t */\n\tprotected end: number;\n\n\t/**\n\t * The type of values in the range: 'number' or 'string'.\n\t */\n\tprotected type: RangeVal;\n\n\t/**\n\t * Creates a new instance of the Range class.\n\t *\n\t * @param {RangeType} start - The starting value of the range, which can be a number or a string.\n\t * @param {RangeType} end - The ending value of the range, which can be a number or a string.\n\t * @throws {TypeError} If start and end are of different types.\n\t */\n\tconstructor(start: RangeType, end?: RangeType) {\n\t\tif (end && typeof start !== typeof end) {\n\t\t\tthrow new TypeError(\"Start and end must be of the same type.\");\n\t\t}\n\n\t\tthis.type = typeof start === \"number\" ? \"number\" : \"string\";\n\t\tthis.start = typeof start === \"number\" ? start : start.charCodeAt(0);\n\t\tthis.end =\n\t\t\t(typeof end === \"number\" ? end : end?.charCodeAt(0)) ?? Infinity;\n\t}\n\n\t[Symbol.iterator]() {\n\t\tlet i = this.start;\n\t\tconst that = this;\n\n\t\tif (this.type === \"number\") {\n\t\t\treturn {\n\t\t\t\tnext() {\n\t\t\t\t\tif (i <= that.end) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tvalue: i++,\n\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: null,\n\t\t\t\t\t\tdone: true,\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t[Symbol.iterator]() {\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tnext() {\n\t\t\t\t\tif (i <= that.end) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tvalue: String.fromCharCode(i++),\n\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: null,\n\t\t\t\t\t\tdone: true,\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t[Symbol.iterator]() {\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n}\n","import { FirstLastList } from \"~core/linked-list\";\n\n/**\n * @description Класс структуры Stack.\n */\nexport default class Stack<T> {\n\treadonly #innerStruct: FirstLastList<T>;\n\n\tconstructor() {\n\t\tthis.#innerStruct = new FirstLastList();\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.#innerStruct[Symbol.iterator]();\n\t}\n\n\t/**\n\t * @description Добавляет элемент в стек.\n\t * @param item Новый элемент стека\n\t */\n\tpublic insert(item: T) {\n\t\tthis.#innerStruct.insertFirst(item);\n\t}\n\n\t/**\n\t * @description Удаляет элемент из стек.\n\t */\n\tpublic remove() {\n\t\treturn this.#innerStruct.removeFirst();\n\t}\n\n\t/**\n\t * @description Возвращает true, если стек пустой, и false в обратном случае.\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn this.#innerStruct.isEmpty();\n\t}\n\n\t/**\n\t * @description Очищает стек.\n\t */\n\tpublic clear() {\n\t\tthis.#innerStruct.clear();\n\t}\n}\n","/**\n * Splits a string into an array of lines.\n *\n * This function takes a string and splits it into an array of substrings,\n * where each substring represents a line of text. It uses newline characters\n * as the delimiter. If the input string is empty, it returns an array containing\n * the empty string.\n *\n * @param {string} s - The input string to be split into lines.\n * @returns {string[]} An array of strings, where each string is a line from the input.\n *\n * @example\n * const result = lines(\"Hello\\nWorld\");\n * console.log(result); // ['Hello', 'World']\n */\nexport function lines(s: string): string[] {\n\treturn [...linesIter(s)];\n}\n\n/**\n * Creates an iterator that yields lines from a string lazily.\n *\n * This function returns an iterator that lazily produces each line of the\n * input string when called. It uses a regular expression to match lines,\n * allowing for efficient memory usage when processing large strings.\n *\n * @param {string} s - The input string to iterate over.\n * @returns {IterableIterator<string>} An iterator that yields each line of the\n * string.\n *\n * @example\n * const iterator = linesIter(\"Hello\\nWorld\");\n * for (const line of iterator) {\n *   console.log(line); // Outputs: 'Hello' then 'World'\n * }\n */\nexport function linesIter(s: string): IterableIterator<string> {\n\tconst re = /^.+$/gm;\n\n\tlet line = re.exec(s);\n\n\treturn {\n\t\tnext() {\n\t\t\tif (line) {\n\t\t\t\tconst val = line[0];\n\n\t\t\t\tline = re.exec(s);\n\n\t\t\t\treturn {\n\t\t\t\t\tvalue: val,\n\t\t\t\t\tdone: false,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tvalue: null,\n\t\t\t\tdone: true,\n\t\t\t};\n\t\t},\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this;\n\t\t},\n\t};\n}\n\n/**\n * Combines an iterable collection of strings into a single string,\n * with each element separated by a newline character (`\\n`).\n *\n * This function is useful for creating multiline strings from an array of\n * lines. If the input iterable is empty, the function will return an\n * empty string.\n *\n * @param {Iterable<string>} iterable - An iterable collection of strings to\n * be joined. Each string will be concatenated with a newline character in between.\n * @returns {string} A single string containing all the elements from the iterable\n * joined by newline characters. Returns an empty string if the iterable is empty.\n *\n * @example\n * const result = unLines(['Hello', 'World']);\n * console.log(result); // 'Hello\\nWorld'\n */\nexport function unLines(iterable: Iterable<string>): string {\n\tconst a = [...iterable];\n\n\tif (a.length === 0) {\n\t\treturn \"\";\n\t}\n\n\treturn a.join(\"\\n\");\n}\n","/**\n * Splits a string into an array of words.\n *\n * This function uses a regular expression to identify words in the input string.\n * Words are defined as sequences of non-whitespace characters bounded by word boundaries.\n *\n * @param {string} s - The input string to be split into words.\n * @returns {string[]} An array of words extracted from the input string.\n *\n * @example\n * const result = words(\"Hello, world!\");\n * console.log(result); // [\"Hello,\", \"world!\"]\n */\nexport function words(s: string): string[] {\n\treturn [...wordsIter(s)];\n}\n\n/**\n * An iterable iterator that produces words from a string one at a time.\n *\n * This function uses a regular expression to find words in the input string.\n * Words are defined as sequences of non-whitespace characters bounded by word boundaries.\n *\n * @param {string} s - The input string to iterate over for words.\n * @returns {IterableIterator<string>} An iterable iterator that yields words from the input\n * string.\n *\n * @example\n * const iterator = wordsIter(\"Hello, world!\");\n * for (const word of iterator) {\n *   console.log(word); // \"Hello,\", then \"world!\"\n * }\n */\nexport function wordsIter(s: string): IterableIterator<string> {\n\tconst re = /\\b[^\\s]+\\b/g;\n\n\tlet word = re.exec(s);\n\n\treturn {\n\t\tnext() {\n\t\t\tif (word) {\n\t\t\t\tconst val = word[0];\n\n\t\t\t\tword = re.exec(s);\n\n\t\t\t\treturn {\n\t\t\t\t\tvalue: val,\n\t\t\t\t\tdone: false,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tvalue: null,\n\t\t\t\tdone: true,\n\t\t\t};\n\t\t},\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this;\n\t\t},\n\t};\n}\n\n/**\n * Joins an iterable of words into a single string with a specified separator.\n *\n * If the iterable is empty, an empty string is returned. The default separator is a space.\n *\n * @param {Iterable<string>} iterable - An iterable collection of words to join.\n * @param {CanUndef<string>} separator - The string to use as a separator between words (default is a space).\n * @returns {string} A single string formed by joining the words with the specified separator.\n *\n * @example\n * const result = unWords([\"Hello,\", \"world!\"]);\n * console.log(result); // \"Hello, world!\"\n *\n * @example\n * const resultWithCustomSeparator = unWords([\"Hello,\", \"world!\"], \"-\");\n * console.log(resultWithCustomSeparator); // \"Hello,-world!\"\n */\nexport function unWords(\n\titerable: Iterable<string>,\n\tseparator: CanUndef<string> = \" \",\n): string {\n\tconst a = [...iterable];\n\n\tif (a.length === 0) {\n\t\treturn \"\";\n\t}\n\n\treturn a.join(separator);\n}\n","import type { CacheOptions, CacheStrategy } from \"~core/cache-data/interface\";\nimport DefaultStrategy from \"~core/cache-data/strategy\";\n\nexport default class CacheData<T> {\n\t#strategy: CacheStrategy<T>;\n\n\tconstructor(opts?: CacheOptions<T>) {\n\t\tthis.#strategy = opts?.strategy ?? new DefaultStrategy();\n\t}\n\n\tpublic get(key: string) {\n\t\treturn this.#strategy.get(key);\n\t}\n\n\tpublic hasKey(key: string): boolean {\n\t\treturn this.#strategy.hasKey(key);\n\t}\n\n\tpublic set(key: string, value: T): void {\n\t\tthis.#strategy.set(key, value);\n\t}\n\n\tpublic remove(key: string): void {\n\t\tthis.#strategy.remove(key);\n\t}\n\n\tpublic clear(): void {\n\t\tthis.#strategy.clear();\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this.#strategy.isEmpty();\n\t}\n\n\tpublic isFull() {\n\t\treturn this.#strategy.isFull();\n\t}\n}\n","import { Handler } from \"~core/event/interfaces\";\n\nexport { default as streamEvent } from \"./stream\";\n\n/**\n * @description Класс для работы с событиями.\n */\nexport default class EventEmitter<T> {\n\t// todo callback type\n\treadonly #handlers: Map<string, Set<Handler<T>>>;\n\n\tget handlers() {\n\t\treturn this.#handlers;\n\t}\n\n\tconstructor() {\n\t\tthis.#handlers = new Map();\n\t}\n\n\tprivate hasKey(event: string) {\n\t\treturn this.#handlers.has(event);\n\t}\n\n\tpublic clear() {\n\t\tthis.#handlers.clear();\n\t}\n\n\tpublic once(event: string, cb: (v: T) => unknown) {\n\t\tconst handlers = this.#handlers.get(event);\n\n\t\tconst cbWrap = (v: T) => {\n\t\t\tcb(v);\n\n\t\t\tif (handlers) {\n\t\t\t\thandlers.delete(cbWrap);\n\t\t\t} else {\n\t\t\t\tthis.#handlers.delete(event);\n\t\t\t}\n\t\t};\n\n\t\tif (handlers) {\n\t\t\thandlers.add(cbWrap);\n\t\t} else {\n\t\t\tthis.#handlers.set(event, new Set([cbWrap]));\n\t\t}\n\t}\n\n\tpublic on(event: string, cb: (v: T) => unknown) {\n\t\tconst handlers = this.#handlers.get(event);\n\n\t\tif (handlers) {\n\t\t\thandlers.add(cb);\n\t\t} else {\n\t\t\tthis.#handlers.set(event, new Set([cb]));\n\t\t}\n\t}\n\n\tpublic off(event: string, cb?: (v: unknown) => unknown) {\n\t\tif (!cb) {\n\t\t\tthis.#handlers.delete(event);\n\t\t\treturn;\n\t\t}\n\n\t\tconst handlers = this.#handlers.get(event);\n\n\t\tif (handlers) {\n\t\t\thandlers.delete(cb);\n\t\t}\n\t}\n\n\tpublic emit(event: string, val: T) {\n\t\tconst handlers = this.#handlers.get(event);\n\n\t\tif (handlers) {\n\t\t\tfor (const handler of handlers) {\n\t\t\t\thandler(val);\n\t\t\t}\n\t\t}\n\t}\n}\n","import type { CacheStrategy } from \"~core/cache-data/strategy/interface\";\nimport type { LRUCacheOptions } from \"~core/cache-data/strategy/lru/interface\";\n\n/**\n * @description Класс LRU-кеширования.\n */\nexport default class LRUCache<T> implements CacheStrategy<T> {\n\t#queue: Map<string, T>;\n\n\treadonly #maxSize: number;\n\n\tconstructor(opts?: LRUCacheOptions) {\n\t\t// todo\n\t\t// if (opts?.maxSize <= 0) {\n\t\t// \tthrow new RangeError(\"maxSize cache must be greater than 0\");\n\t\t// }\n\n\t\tthis.#maxSize = opts?.maxSize ?? 10;\n\t\tthis.#queue = new Map([]);\n\t}\n\n\tpublic hasKey(key: string): boolean {\n\t\treturn this.#queue.has(key);\n\t}\n\n\tpublic get(key: string): T | undefined {\n\t\tconst val: T | undefined = this.#queue.get(key);\n\n\t\tif (val) {\n\t\t\tthis.#queue.delete(key);\n\t\t\tthis.#queue.set(key, val);\n\t\t\treturn val;\n\t\t}\n\t}\n\n\tpublic set(key: string, value: T): void {\n\t\tif (this.#queue.has(key)) {\n\t\t\tthis.#queue.delete(key);\n\t\t}\n\n\t\tif (this.#maxSize <= this.#queue.size) {\n\t\t\tthis.#queue.delete(this.#queue.keys().next().value);\n\t\t}\n\n\t\tthis.#queue.set(key, value);\n\t}\n\n\tpublic remove(key: string): void {\n\t\t// todo\n\t\tthis.#queue.delete(key);\n\t}\n\n\tpublic clear(): void {\n\t\tthis.#queue.clear();\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this.#queue.size === 0;\n\t}\n\n\tpublic isFull(): boolean {\n\t\treturn this.#queue.size === this.#maxSize;\n\t}\n}\n","import DefaultEngine, { LoggerEngine } from \"~core/logger/engines\";\nimport type { LoggerOpts } from \"~core/logger/interface\";\n\nexport { LoggerOpts, LoggerEngine } from \"~core/logger/interface\";\nexport { default as ConsoleEngine } from \"~core/logger/engines/console\";\n\nexport default class Logger {\n\tpublic namespace: string;\n\n\t#engine: LoggerEngine;\n\n\tconstructor(namespace: string, loggerOpts?: LoggerOpts) {\n\t\tthis.namespace = namespace;\n\t\tthis.#engine = loggerOpts?.engine ?? new DefaultEngine();\n\t}\n\n\tpublic log(msg: string, ...args: unknown[]) {\n\t\tthis.#engine.log(msg, ...args);\n\t}\n\n\tpublic warn(msg: string, ...args: unknown[]) {\n\t\tthis.#engine.warn(msg, ...args);\n\t}\n\n\tpublic error(err: string | Error, ...args: unknown[]) {\n\t\tthis.#engine.error(err, ...args);\n\t}\n}\n","export function asyncForeach<T>(\n\titerable: Iterable<T>,\n\ttimePoint: number = 100,\n\ttimeout: number = 200,\n) {\n\tconst iter = iterable[Symbol.iterator]();\n\n\tlet timer: ReturnType<typeof setTimeout>,\n\t\ttime = Date.now();\n\n\treturn {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\n\t\tasync next() {\n\t\t\tconst res = iter.next();\n\n\t\t\tif (Date.now() - time > timePoint) {\n\t\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\t\ttimer = setTimeout(() => {\n\t\t\t\t\t\t// if (cbTimeout) {\n\t\t\t\t\t\t// \tcbTimeout(el);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\ttime = Date.now();\n\t\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\t\tresolve(\"setTimeout is done\");\n\t\t\t\t\t}, timeout);\n\t\t\t\t}).then((v) => {\n\t\t\t\t\tconsole.log(v);\n\t\t\t\t});\n\n\t\t\t\treturn Promise.resolve(res);\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve(res);\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport function iterInterval<T>(iterable: AsyncIterable<T>, interval: number) {\n\tconst iter = iterable[Symbol.asyncIterator]();\n\n\treturn {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\n\t\tasync next() {\n\t\t\tconst res = iter.next();\n\n\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\tconst timer = setTimeout(() => {\n\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\tresolve(res);\n\t\t\t\t}, interval);\n\t\t\t});\n\n\t\t\treturn Promise.resolve(res);\n\t\t},\n\t};\n}\n","/**\n * @description Функция, которая принимает функцию и возвращает ее debounce-версию.\n * @param fn\n * @param time\n */\nexport function debounce(fn: Function, time: number) {\n\tlet timeout: CanNull<ReturnType<typeof setTimeout>>;\n\n\treturn function (this: unknown, ...args: unknown[]) {\n\t\tif (timeout != null) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\n\t\ttimeout = setTimeout(() => {\n\t\t\tfn.apply(this, args);\n\t\t\ttimeout = null;\n\t\t}, time);\n\t};\n}\n\n/**\n * @description Функция, которая принимает функцию и возвращает ее throttle-версию.\n * @param fn\n */\nexport function throttle(fn: Function, time: number) {\n\tlet timeout: CanNull<ReturnType<typeof setTimeout>>,\n\t\tlastArgs: unknown[] = [];\n\n\treturn function wrapper(this: unknown, ...args: unknown[]) {\n\t\tlastArgs = args;\n\n\t\tif (timeout == null) {\n\t\t\tfn.apply(this, args);\n\n\t\t\ttimeout = setTimeout(() => {\n\t\t\t\ttimeout = null;\n\n\t\t\t\tif (lastArgs !== args) {\n\t\t\t\t\twrapper.apply(this, lastArgs);\n\t\t\t\t}\n\t\t\t}, time);\n\t\t}\n\t};\n}\n","export { asyncForeach } from \"~core/iter/async\";\nexport { iterInterval } from \"~core/iter/async\";\n\nexport function map<T, U>(\n\titerable: Iterable<T>,\n\tcallback: (value: T, index?: number, iterable?: Iterable<T>) => U,\n\tthisArg?: unknown,\n) {\n\tconst iter = iterable[Symbol.iterator]();\n\n\tlet i = 0;\n\n\treturn {\n\t\t[Symbol.iterator]() {\n\t\t\treturn this;\n\t\t},\n\n\t\tnext() {\n\t\t\tconst res = iter.next();\n\n\t\t\tif (!res.done) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: callback.call(thisArg, res.value, i++, iterable),\n\t\t\t\t\tdone: res.done,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\t};\n}\n\nexport function filter<T>(\n\titerable: Iterable<T>,\n\tpredicate: (value: T, index?: number, iterable?: Iterable<T>) => boolean,\n\tthisArg?: unknown,\n) {\n\tconst iter = iterable[Symbol.iterator]();\n\n\tlet i = 0;\n\n\treturn {\n\t\t[Symbol.iterator]() {\n\t\t\treturn this;\n\t\t},\n\n\t\tnext() {\n\t\t\tlet res = iter.next(),\n\t\t\t\tisCondition = predicate.call(thisArg, res.value, i++, iterable);\n\n\t\t\twhile (!res.done && !isCondition) {\n\t\t\t\tres = iter.next();\n\t\t\t\tisCondition = predicate.call(thisArg, res.value, i++, iterable);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\t};\n}\n\nexport function enumerate<T>(iterable: Iterable<T>) {\n\tconst iter = iterable[Symbol.iterator]();\n\n\tlet count = 1;\n\n\treturn {\n\t\t[Symbol.iterator]() {\n\t\t\treturn this;\n\t\t},\n\n\t\tnext() {\n\t\t\tconst res = iter.next();\n\n\t\t\tif (!res.done) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: [count++, res.value],\n\t\t\t\t\tdone: res.done,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\t};\n}\n\nexport function take<T>(iterable: Iterable<T>, count: number) {\n\tconst iter = iterable[Symbol.iterator]();\n\n\tlet i = 0;\n\n\treturn {\n\t\t[Symbol.iterator]() {\n\t\t\treturn this;\n\t\t},\n\n\t\tnext() {\n\t\t\tconst res = iter.next();\n\n\t\t\tif (!res.done && i++ < count) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: res.value,\n\t\t\t\t\tdone: res.done,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tvalue: null,\n\t\t\t\tdone: true,\n\t\t\t};\n\t\t},\n\t};\n}\n\nexport function repeat<T>(iterable: Iterable<T>, count: number) {\n\tif (count === 0) {\n\t\treturn {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tnext() {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: null,\n\t\t\t\t\tdone: true,\n\t\t\t\t};\n\t\t\t},\n\t\t};\n\t}\n\n\tlet iter = iterable[Symbol.iterator]();\n\n\tlet i = 1;\n\n\treturn {\n\t\t[Symbol.iterator]() {\n\t\t\treturn this;\n\t\t},\n\n\t\tnext() {\n\t\t\tlet res = iter.next();\n\n\t\t\tif (res.done && i >= count) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: null,\n\t\t\t\t\tdone: true,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (res.done) {\n\t\t\t\ti++;\n\t\t\t\titer = iterable[Symbol.iterator]();\n\t\t\t\tres = iter.next();\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tvalue: res.value,\n\t\t\t\tdone: false,\n\t\t\t};\n\t\t},\n\t};\n}\n","import EventEmitter from \"~core/event/index\";\nimport { Handler } from \"~core/event/interfaces\";\n\n/**\n * @description Функция для создания потока событий через асинхронный итератор.\n * @template T\n * @param {EventEmitter} ee\n * @param {string} event\n * @returns {AsyncIterableIterator<T>}\n */\nexport default function streamEvent<T>(\n\tee: EventEmitter<T>,\n\tevent: string,\n): AsyncIterableIterator<T> {\n\tconst resolvers: Set<Handler<T>> = new Set();\n\n\t// todo Переделать, когда будет модуль очереди\n\tconst queue: T[] = [];\n\n\tee.on(event, handler);\n\n\treturn {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\n\t\tnext() {\n\t\t\treturn new Promise((r) => {\n\t\t\t\tconst e: T | undefined = queue.shift();\n\n\t\t\t\tif (e) {\n\t\t\t\t\tr({\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: e,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresolvers.add((v) =>\n\t\t\t\t\t\tr({\n\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\tvalue: v,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t};\n\n\tfunction handler(e: T) {\n\t\tif (resolvers.size > 0) {\n\t\t\ttry {\n\t\t\t\tresolvers.forEach((r) => r(e));\n\t\t\t} finally {\n\t\t\t\tresolvers.clear();\n\t\t\t}\n\t\t} else {\n\t\t\tqueue.push(e);\n\t\t}\n\t}\n}\n","export default function symbolGenerator() {\n\treturn new Proxy<Record<string | symbol, symbol>>(\n\t\t{},\n\t\t{\n\t\t\tget(target, p) {\n\t\t\t\tif (p in target) {\n\t\t\t\t\treturn target[p];\n\t\t\t\t}\n\n\t\t\t\treturn (target[p] = Symbol(String(p)));\n\t\t\t},\n\t\t},\n\t);\n}\n","import { WatchHandler } from \"~core/object/watch/interfaces\";\n\nexport type { WatchHandler };\n\nexport default function watch<T extends object>(\n\tobj: T,\n\thandler: WatchHandler<unknown>,\n\tpath: (string | symbol)[] = [],\n): T {\n\tconst proxy = new Proxy<T>(obj, {\n\t\tget(target, p, receiver) {\n\t\t\tconst val = Reflect.get(target, p, receiver);\n\n\t\t\tif (\n\t\t\t\ttypeof val === \"function\" &&\n\t\t\t\t/\\[native code]/.test(val.toString())\n\t\t\t) {\n\t\t\t\tif (Array.isArray(target)) {\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\n\t\t\t\tif (target instanceof Map) {\n\t\t\t\t\tswitch (p) {\n\t\t\t\t\t\tcase \"set\":\n\t\t\t\t\t\t\treturn (key: unknown, valToSet: unknown) => {\n\t\t\t\t\t\t\t\thandler(valToSet, target.get(key), [...path, key]);\n\t\t\t\t\t\t\t\treturn val.call(target, key, valToSet);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\tcase \"get\":\n\t\t\t\t\t\t\treturn (key: unknown) => {\n\t\t\t\t\t\t\t\tconst valFromGet = val.call(target, key);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tvalFromGet != null &&\n\t\t\t\t\t\t\t\t\ttypeof valFromGet === \"object\"\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn watch(valFromGet, handler, [...path, p]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// if (p === \"set\") {\n\t\t\t\t\t// \treturn (key: unknown, valToSet: unknown) => {\n\t\t\t\t\t// \t\thandler(valToSet, target.get(key), [...path, key]);\n\t\t\t\t\t// \t\treturn val.call(target, key, valToSet);\n\t\t\t\t\t// \t};\t\t\t\t\t//\n\t\t\t\t\t// } else if (p === \"get\") {\n\t\t\t\t\t// \treturn (key: unknown) => {\n\t\t\t\t\t// \t\tconst valFromGet = val.call(target, key);\n\t\t\t\t\t// \t\tif (valFromGet != null && typeof valFromGet === \"object\") {\n\t\t\t\t\t// \t\t\treturn watch(valFromGet, handler, [...path, p]);\n\t\t\t\t\t// \t\t}\n\t\t\t\t\t// \t};\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (val != null && typeof val === \"object\") {\n\t\t\t\treturn watch(val, handler, [...path, p]);\n\t\t\t}\n\n\t\t\treturn val;\n\t\t},\n\n\t\tset(target, p, value, receiver) {\n\t\t\tconst old = Reflect.get(target, p, receiver),\n\t\t\t\tres = Reflect.set(target, p, value, receiver);\n\n\t\t\tif (res) {\n\t\t\t\thandler(value, old, [...path, p]);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\n\t\tdeleteProperty(target, p) {\n\t\t\tconst old = Reflect.get(target, p, proxy),\n\t\t\t\tres = Reflect.deleteProperty(target, p);\n\n\t\t\tif (res) {\n\t\t\t\thandler(undefined, old, [...path, p]);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\t});\n\n\treturn proxy;\n}\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","get","__classPrivateFieldSet","set","SuppressedError","SimpleCache","constructor","_SimpleCache_cacheMap","this","Map","hasKey","key","remove","delete","clear","isEmpty","size","isFull","Option","isNone","_Option_data","data","unwrap","Error","cb","None","err","or","option","undefined","Result","isError","_Result_data","console","log","LLNode","Symbol","iterator","node","temp","LinkedList","first","_b","firstNode","_a","length","lengthList","iterable","el","insertFirst","item","newNode","removeFirst","val","reverse","prev","current","FLNode","FirstLastList","last","lastNode","insertLast","DLNode","DoubleLinkedList","removeLast","ConsoleEngine","msg","args","warn","error","Queue","innerStruct","insert","Deque","Range","start","end","type","charCodeAt","Infinity","i","that","String","fromCharCode","Stack","_Stack_innerStruct","WeakMap","linesIter","s","re","line","exec","wordsIter","word","opts","_CacheData_strategy","strategy","DefaultStrategy","handlers","_EventEmitter_handlers","event","once","cbWrap","v","add","Set","on","off","emit","handler","_LRUCache_queue","_LRUCache_maxSize","maxSize","keys","namespace","loggerOpts","_Logger_engine","engine","DefaultEngine","timePoint","timeout","iter","timer","time","Date","now","asyncIterator","res","setTimeout","clearTimeout","fn","count","predicate","isCondition","interval","callback","ee","resolvers","queue","forEach","r","push","shift","Proxy","target","p","lastArgs","wrapper","a","join","separator","watch","obj","path","proxy","Reflect","test","toString","Array","isArray","valToSet","valFromGet","old","deleteProperty"],"mappings":"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","x_google_ignoreList":[0]}